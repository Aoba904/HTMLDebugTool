// Generated by CoffeeScript 1.6.3
(function() {
  var Parser, Query, Selector, Tag, avoidChar, isEmpty, isSpecal, parser, selector;

  Query = (function() {
    function Query() {}

    Query.prototype.bind = function(name, func) {
      this.each(function(t) {
        return t.attaribute["on" + name] = func.toString().replace(/^function.+{|}$/g, "").replace(/\n/g, "");
      });
      return this;
    };

    Query.prototype.attr = function(name, val) {
      this.each(function(t) {
        return t.attaribute[name] = val;
      });
      return this;
    };

    Query.prototype.append = function() {
      var t, tag, _i, _len;
      t = this[0];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        tag = arguments[_i];
        tag.parentNode = t;
        [].push.call(t.children, tag);
      }
      return this;
    };

    Query.prototype.remove = function() {
      var args;
      args = arguments;
      this.each(function(t) {
        var index, tag, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          tag = args[_i];
          index = [].indexOf.call(this, tag);
          if (index === -1) {
            _results.push([].splice.call(t.children, index, 1));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      return this;
    };

    Query.prototype.each = function(func) {
      var key, val, _i, _len;
      for (key = _i = 0, _len = this.length; _i < _len; key = ++_i) {
        val = this[key];
        func(val, key);
      }
      return this;
    };

    Query.prototype.filter = function(expr) {
      return selector.filter(this, expr);
    };

    Query.prototype.find = function(expr) {
      return selector.exec(this, expr);
    };

    Query.prototype.wrap = function(elem) {
      var child, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        child = this[_i];
        if ([].indexOf.call(elem.children, child) === -1) {
          [].push.call(elem.children, child);
        }
      }
      return this;
    };

    Query.prototype.clone = function() {
      var query;
      query = new Query;
      this.each(function(t) {
        return [].push.call(query, t);
      });
      return query;
    };

    Query.prototype.text = function(str) {
      var child, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        child = this[_i];
        child.innerText = str;
      }
      return this;
    };

    Query.prototype.html = function(str) {
      var child, html, _i, _len;
      if (str) {
        html = parser.parse(str);
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          child = this[_i];
          [].push.call(child.children, html);
        }
        return this;
      } else {
        return this[0].toString();
      }
    };

    return Query;

  })();

  Tag = (function() {
    function Tag(name, attr, parent) {
      this.tagName = name;
      this.attaribute = attr;
      this.parentNode = parent;
      this.children = new Query;
      this.innerText = "";
    }

    Tag.prototype.toElement = function() {
      var div;
      div = document.createElement("div");
      div.innerHTML = this.toString();
      return div.children[0];
    };

    Tag.prototype.$ = function(str) {
      return selector.exec(this, str);
    };

    Tag.prototype.toString = function() {
      var key, str, val, _i, _len, _ref, _ref1;
      str = "<" + this.tagName;
      _ref = this.attaribute;
      for (key in _ref) {
        val = _ref[key];
        str += " " + key + '="' + val + '"';
      }
      str += ">" + this.innerText;
      _ref1 = this.children;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        val = _ref1[_i];
        str += val.toString();
      }
      if (!isEmpty(this.tagName)) {
        str += '</' + this.tagName + '>';
      }
      return str;
    };

    return Tag;

  })();

  Selector = (function() {
    function Selector() {
      this.rgeselector = /[\.|#]\w+|[^\.|#|\s]+/g;
      this.rgeclass = /^\./;
      this.rgeid = /^#/;
      this.base;
      this.results;
    }

    Selector.prototype.parse = function(str) {
      return str.match(this.rgeselector);
    };

    Selector.prototype.filter = function(tag, str) {
      var tree, val, _i, _len;
      tree = this.parse(str);
      this.results = new Query;
      for (_i = 0, _len = tree.length; _i < _len; _i++) {
        val = tree[_i];
        this.list(tag, val);
      }
      return this.results;
    };

    Selector.prototype.exec = function(tag, str) {
      var tree, val, _i, _len;
      tree = this.parse(str);
      this.results = new Query;
      for (_i = 0, _len = tree.length; _i < _len; _i++) {
        val = tree[_i];
        this.search(tag, val);
      }
      return this.results;
    };

    Selector.prototype.search = function(tag, str) {
      var child, _i, _len, _ref, _results;
      this.list(tag, str);
      _ref = this.base;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(this.search(child, str));
      }
      return _results;
    };

    Selector.prototype.list = function(tag, str) {
      this.base = tag.children || tag;
      if (this.rgeclass.test(str)) {
        return this["class"](str.replace(this.rgeclass, ""));
      } else if (this.rgeid.test(str)) {
        return this.id(str.replace(this.rgeid, ""));
      } else {
        return this.tag(str);
      }
    };

    Selector.prototype["class"] = function(str) {
      var child, _i, _len, _ref, _results;
      _ref = this.base;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.attaribute["class"] === str) {
          _results.push([].push.call(this.results, child));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Selector.prototype.id = function(str) {
      var child, _i, _len, _ref, _results;
      _ref = this.base;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.attaribute.id === str) {
          _results.push([].push.call(this.results, child));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Selector.prototype.tag = function(str) {
      var child, _i, _len, _ref, _results;
      _ref = this.base;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.tagName === str) {
          _results.push([].push.call(this.results, child));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Selector;

  })();

  isEmpty = function(str) {
    switch (str.length) {
      case 2:
        return (str === "br") || (str === "hr");
      case 3:
        return (str === "img") || (str === "col");
      case 4:
        return (str === "meta") || (str === "link") || (str === "area") || (str === "base");
      case 5:
        return (str === "input") || (str === "frame") || (str === "embed") || (str === "param");
      case 7:
        return str === "isindex";
      case 8:
        return str === "basefont";
      default:
        return false;
    }
  };

  isSpecal = function(str) {
    return (str === "style") || (str === "script");
  };

  avoidChar = function(str, char, count) {
    var avoid, c, s, _i, _len;
    avoid = 0;
    s = "";
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      c = str[_i];
      if (avoid < count && c === char) {
        avoid++;
      } else {
        s += c;
      }
    }
    return s;
  };

  Parser = (function() {
    function Parser() {
      this.rgeTag = /^<\w+(?:\s+[^>]+)?\/?>/;
      this.rgeEndTag = /^<\/\w+>/;
      this.rgeAttr = /[^\s<>="]+="(\\w*[^"]*)?"|[^\s<>]+/g;
      this.regAttrName = /[^\s=>"]+/;
      this.regStr = /^"(\w*[^"]*)?"/;
      this.parent = void 0;
      this.stack = void 0;
      this.stacktab = 0;
      this.isspecal = false;
      this.isinstring = false;
    }

    Parser.prototype.parse = function(source) {
      var char, cmo, count, m, max, test;
      this.constructor();
      max = source.length;
      count = 0;
      char = true;
      test = false;
      while (source) {
        count++;
        if (count > max) {
          console.log("maximum stack length!");
          break;
        }
        if (!this.isspecal) {
          char = true;
          if (source.indexOf("<!--") === 0) {
            m = source.indexOf("-->");
            if (m >= 0) {
              char = false;
              cmo = source.substring(4, m);
              source = source.substring(m + 3);
            }
          } else if (source.indexOf("</") === 0) {
            m = source.match(this.rgeEndTag);
            if (m) {
              char = false;
              m = m[0];
              this.parseEndTag(m);
              source = source.substring(m.length);
            }
          } else if (source.indexOf("<") === 0) {
            m = source.match(this.rgeTag);
            if (m) {
              char = false;
              m = m[0];
              this.parseTag(m);
              source = source.substring(m.length);
            }
          }
          if (char) {
            m = source.indexOf("<");
            source = m === -1 ? "" : (m = m || 1, this.stack ? this.stack.innerText += this.parseInnerText(source.substring(0, m)) : void 0, source.substring(m));
          }
        } else {
          source = this.parseSpecalText(source);
          test = true;
          this.isspecal = false;
        }
      }
      return this.parent;
    };

    Parser.prototype.parseTag = function(str) {
      var attr, char, count, inattr, lastattr, m, max, name, tag;
      char = true;
      name = void 0;
      attr = {};
      lastattr = "";
      inattr = null;
      max = str.length;
      count = 0;
      while (str) {
        char = true;
        count++;
        if (count > max) {
          console.log("maximum stack length!");
          break;
        }
        if (/^[a-zA-Z]/.test(str)) {
          m = str.match(this.regAttrName);
          if (m) {
            char = false;
            m = m[0];
            if (!name) {
              name = m.toLowerCase();
            } else {
              lastattr = m.toLowerCase();
              inattr = null;
              attr[lastattr] = true;
            }
            str = str.substring(m.length);
          }
        } else if (str.indexOf('"') === 0) {
          m = str.match(this.regStr);
          if (m) {
            char = false;
            m = m[0];
            if (inattr) {
              attr[inattr] = m.replace(/^"|"$/g, "");
            }
            str = str.substring(m.length);
          }
        } else if (str.indexOf('=') === 0) {
          char = false;
          inattr = lastattr;
          str = str.substring(1);
        }
        if (char) {
          str = str.substring(1);
        }
      }
      tag = new Tag(name, attr, this.parent);
      if (this.parent) {
        [].push.call(this.parent.children, tag);
      }
      this.isspecal = isSpecal(name);
      return this.stack = isEmpty(name) ? tag : this.parent = tag;
    };

    Parser.prototype.parseEndTag = function(str) {
      var name;
      name = str.replace(/\/|<|>|\s/g, "").toLowerCase();
      this.isspecal = false;
      if (name === this.parent.tagName) {
        this.stack = void 0;
        if (this.parent.parentNode) {
          return this.parent = this.parent.parentNode;
        }
      }
    };

    Parser.prototype.parseInnerText = function(str, eltab) {
      var ary, m, syntax, val;
      syntax = true;
      str = (function() {
        var _i, _len;
        if (/^[\t\r\n]+$/.test(str)) {
          if (!eltab) {
            m = str.match(/\t/g);
            this.stacktab = m ? m.length + 1 : 1;
            return "";
          } else {
            return str;
          }
        } else {
          if (/\n/.test(str)) {
            ary = str.split("\n");
            str = "";
            for (_i = 0, _len = ary.length; _i < _len; _i++) {
              val = ary[_i];
              syntax = false;
              if (str !== "") {
                str += "\n";
              }
              str += this.parseInnerText(val, true);
            }
          }
          return str;
        }
      }).call(this);
      str = str.replace(/^[\t\r]*\n|\n[\t\r]*$/g, "");
      if (syntax) {
        return avoidChar(str, "\t", this.stacktab);
      } else {
        return str;
      }
    };

    Parser.prototype.parseSpecalText = function(source) {
      var char, count, isstrarg, m, max, split, str;
      max = source.length;
      char = true;
      isstrarg = false;
      count = 0;
      str = "";
      while (1) {
        count++;
        if (count > max) {
          console.log("maximum stack length!");
          break;
        }
        char = true;
        split = m = source.indexOf('</') + 2;
        if (m < 0) {
          str = source;
          source = "";
          break;
        }
        source.replace(/"|\\(?:")/g, function(char, len) {
          if (len < m && char === '"') {
            return isstrarg = !isstrarg;
          }
        });
        str += source.substring(0, split);
        source = source.substring(split);
        if (!isstrarg) {
          str = this.parseInnerText(str.substring(0, str.length - 2));
          source = "</" + source;
          break;
        }
      }
      if (this.stack) {
        this.stack.innerText = str;
      }
      return source;
    };

    return Parser;

  })();

  selector = new Selector;

  parser = new Parser;

  module.exports = Parser;

}).call(this);

/*
//@ sourceMappingURL=HTMLParser.map
*/
