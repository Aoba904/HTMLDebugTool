// Generated by CoffeeScript 1.6.3
(function() {
  var ClosureCompiler, FS, HTMLParser, HTTP, Observer, create, cuttingModule, extension, getExtensionType, htmlparser, modulesource;

  HTTP = require("http");

  FS = require("fs");

  Observer = require("./Observer.js");

  ClosureCompiler = require("./ClosureCompiler.js");

  HTMLParser = require("./HTMLParser.js");

  htmlparser = new HTMLParser;

  modulesource = "";

  extension = {
    ".txt": "text/plain",
    ".map": "text/plain",
    ".js": "text/javascript",
    ".css": "text/css",
    ".htm": "text/html",
    ".html": "text/html",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".gif": "image/gif",
    ".bmp": "image/bmp",
    ".ico": "image/vnd.microsoft.icon"
  };

  getExtensionType = function(url) {
    var ext, m;
    m = url.match(/\.[^.]+$/);
    if (m.length) {
      return ext = extension[m[0]];
    }
  };

  cuttingModule = function(source) {
    var html, script;
    console.log(":" + modulesource);
    if (modulesource === "") {
      return source;
    }
    source = source.toString("utf-8");
    html = htmlparser.parse(source);
    script = htmlparser.parse('<script type="text/javascript"></script>');
    html.$("body").append(script);
    script.innerText = modulesource;
    return new Buffer(html.toString());
  };

  create = function(port, host, root, callback) {
    var compileModule, connect, index_html, index_source, instance, log, modules, observer, server, stdout;
    root = root === "" ? "./" : root + "/";
    index_html = "index.html";
    index_source = void 0;
    modules = [];
    stdout = "";
    compileModule = function() {
      return ClosureCompiler.compile(modules, {
        type: "local"
      }, function(err, data) {
        if (err) {
          return callback(source);
        }
        return modulesource = data;
      });
    };
    log = function(str) {
      stdout += str + "\n";
      return observer.dispatch("log", {
        message: str
      });
    };
    connect = function() {
      var e;
      log("try create server.");
      try {
        server.listen(port, host, callback.bind(server, false, instance));
        return log("create server to http://" + host + ":" + port);
      } catch (_error) {
        e = _error;
        log("<create error> " + e.message);
        return callback(e.message);
      }
    };
    instance = {
      bindModule: function(ary) {
        modules = ary;
        return compileModule();
      },
      appendModule: function(ary) {
        var val, _i, _len;
        for (_i = 0, _len = ary.length; _i < _len; _i++) {
          val = ary[_i];
          if (modules.indexOf(val) === -1) {
            modules.push(val);
          }
        }
        return compileModule();
      },
      close: function() {
        return server.close();
      },
      on: function(type, func) {
        return server.on(type, func);
      },
      bind: function(type, func) {
        return observer.add(type, func);
      },
      log: function() {
        return stdout;
      }
    };
    observer = new Observer(instance, true);
    server = HTTP.createServer();
    server.on("request", function(req, res) {
      var reqindex, url;
      url = root + req.url.replace(/^\//, "");
      reqindex = false;
      if (url === root) {
        url = root + index_html;
        reqindex = true;
      }
      switch (req.method) {
        case "GET":
          return FS.readFile(url, {}, function(err, source) {
            var ext, stat;
            ext = getExtensionType(url);
            if (err || !ext) {
              res.statusCode = 403;
              res.end();
              if (!/favicon\.ico$/.test(url)) {
                return log("<responce error: " + url + "> " + err);
              }
            } else {
              stat = FS.statSync(url);
              if (reqindex) {
                source = cuttingModule(source);
              }
              res.setHeader("Content-Type", ext + "; charset=utf-8");
              res.setHeader("Content-length", source.length);
              res.setHeader("Last-Modified", stat.mtime);
              return res.end(source);
            }
          });
        case "HEAD":
          return FS.stat(url, function(err, stat) {
            if (err) {
              log("<responce error: " + data.url + "> " + err);
            } else {
              res.setHeader("Content-Type", getExtensionType(url) + "; charset=utf-8");
              res.setHeader("Last-Modified", stat.mtime);
            }
            return res.end();
          });
        default:
          return res.end();
      }
    });
    return connect();
  };

  exports.create = create;

}).call(this);

/*
//@ sourceMappingURL=Server.map
*/
